// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

enum WeightUnit {
  KG
  LB
}

enum HeightUnit {
  CM
  FT_IN
}

enum Sex {
  MALE
  FEMALE
}

enum ActivityLevel {
  SEDENTARY
  LIGHT
  MODERATE
  ACTIVE
  VERY_ACTIVE
}

enum MealPeriod {
  BREAKFAST
  MORNING_SNACK
  LUNCH
  AFTERNOON_SNACK
  DINNER
  EVENING_SNACK
}

enum MyFoodType {
  FOOD
  RECIPE
}

enum RecipeIngredientSource {
  MY_FOOD
  EXTERNAL
}

model User {
  id            Int       @id @default(autoincrement())
  email         String    @unique
  password_hash String
  created_at    DateTime  @default(now())

  weight_unit   WeightUnit @default(KG)
  height_unit   HeightUnit @default(CM)
  /// IANA time zone identifier (e.g. "America/Los_Angeles") used to define the user's local day boundary.
  timezone      String     @default("UTC")
  /// Preferred UI language (short code like "en", "es", "fr", "ru").
  language      String     @default("en")
  /// Account-level preference for weight reminder notifications across devices.
  reminder_log_weight_enabled Boolean @default(true)
  /// Account-level preference for food reminder notifications across devices.
  reminder_log_food_enabled   Boolean @default(true)
  /// Account-level preference that enables/disables app haptic feedback patterns.
  haptics_enabled             Boolean @default(true)
  date_of_birth DateTime?
  sex           Sex?
  height_mm     Int?
  activity_level ActivityLevel?
  /// Optional, processed profile photo (small square) used for in-app avatars.
  profile_image Bytes?
  /// MIME type for the stored profile_image bytes (e.g. "image/jpeg").
  profile_image_mime_type String?
  
  goals         Goal[]
  metrics       BodyMetric[]
  food_logs     FoodLog[]
  food_log_days FoodLogDay[]
  /// User-owned library of reusable foods and recipes for quick logging.
  my_foods      MyFood[]
  /// Web push subscriptions for reminder notifications.
  push_subscriptions PushSubscription[]
}

model Goal {
  id            Int       @id @default(autoincrement())
  user_id       Int
  user          User      @relation(fields: [user_id], references: [id])
  start_weight_grams  Int
  target_weight_grams Int
  target_date   DateTime?
  daily_deficit Int       @default(500)
  created_at    DateTime  @default(now())
}

model BodyMetric {
  id               Int      @id @default(autoincrement())
  user_id          Int
  user             User     @relation(fields: [user_id], references: [id])
  date             DateTime @default(dbgenerated("CURRENT_DATE")) @db.Date
  weight_grams     Int
  body_fat_percent Float?
  /// Materialized trend/confidence values keyed to this day for fast chart responses.
  trend            BodyMetricTrend?
  
  @@unique([user_id, date])
}

model BodyMetricTrend {
  /// Uses the metric id as both primary key and relation key to enforce one trend row per metric.
  metric_id          Int       @id
  metric             BodyMetric @relation(fields: [metric_id], references: [id], onDelete: Cascade)
  /// Duplicated owner id keeps user-scoped deletes and maintenance queries simple.
  user_id            Int
  /// Duplicated metric date allows date-range operations without an additional join.
  date               DateTime  @db.Date
  /// Materialized latent trend estimate in grams.
  trend_weight_grams Int
  /// Materialized lower 95% confidence bound in grams.
  trend_ci_lower_grams Int
  /// Materialized upper 95% confidence bound in grams.
  trend_ci_upper_grams Int
  /// Materialized posterior standard deviation in grams.
  trend_std_grams    Int
  /// Version marker for invalidating persisted rows if model behavior changes later.
  model_version      Int       @default(1)
  /// Timestamp for operational visibility into the latest recompute.
  computed_at        DateTime  @default(now())

  @@index([user_id, date])
}

model FoodLog {
  id          Int      @id @default(autoincrement())
  user_id     Int
  user        User     @relation(fields: [user_id], references: [id])
  /// Optional link to a MyFood item (food/recipe) used to create this entry.
  /// This is informational only; the log remains a snapshot even if the MyFood changes later.
  my_food_id  Int?
  my_food     MyFood?  @relation(fields: [my_food_id], references: [id], onDelete: SetNull)
  date        DateTime @default(now())
  /// Calendar day for grouping logs, derived from the user's timezone at write time.
  local_date  DateTime @db.Date
  /// Fixed meal period for consistent grouping and UI display.
  meal_period MealPeriod
  name        String
  calories    Int
  /// Number of servings consumed for this entry (can be fractional).
  servings_consumed Float?
  /// Snapshot of the serving size (e.g. 1 "slice", 30 "g") used when logging.
  serving_size_quantity_snapshot Float?
  /// Snapshot of the serving unit label (free-form, e.g. "slice", "g", "ml") used when logging.
  serving_unit_label_snapshot String?
  /// Snapshot of calories per serving used when logging (so edits to MyFood do not mutate history).
  calories_per_serving_snapshot Float?
  created_at  DateTime @default(now())

  @@index([user_id, local_date])
}

model FoodLogDay {
  id           Int      @id @default(autoincrement())
  user_id      Int
  user         User     @relation(fields: [user_id], references: [id])
  /// Calendar day for grouping logs, derived from the user's timezone at write time.
  local_date   DateTime @db.Date
  /// Whether the user has marked the day's log as complete.
  is_complete  Boolean  @default(false)
  /// Timestamp of when the day was marked complete (cleared when toggled off).
  completed_at DateTime?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  @@unique([user_id, local_date])
}

model MyFood {
  id          Int       @id @default(autoincrement())
  user_id     Int
  user        User      @relation(fields: [user_id], references: [id])
  /// Indicates whether this item is a simple food (manual definition) or a composed recipe.
  type        MyFoodType
  name        String
  /// Serving size quantity for one serving unit (e.g. 1 "slice", 30 "g").
  serving_size_quantity Float
  /// Free-form serving unit label (e.g. "slice", "g", "ml").
  serving_unit_label String
  /// Calories per serving. For recipes, this is computed from ingredient snapshots and yield.
  calories_per_serving Float
  /// For recipes: total calories across all ingredient snapshots.
  recipe_total_calories Float?
  /// For recipes: number of servings yielded by the recipe (can be fractional).
  yield_servings Float?
  created_at  DateTime  @default(now())
  updated_at  DateTime  @updatedAt

  /// Ingredients belonging to this recipe (only meaningful when type=RECIPE).
  recipe_ingredients RecipeIngredient[] @relation("RecipeToIngredients")
  /// Recipe ingredients that referenced this item at creation time (traceability only; recipes store snapshots).
  used_in_recipe_ingredients RecipeIngredient[] @relation("RecipeIngredientSourceFood")
  food_logs   FoodLog[]

  @@index([user_id, name])
}

model RecipeIngredient {
  id          Int       @id @default(autoincrement())
  recipe_id   Int
  recipe      MyFood    @relation("RecipeToIngredients", fields: [recipe_id], references: [id], onDelete: Cascade)
  /// Stable ordering of ingredients within a recipe.
  sort_order  Int       @default(0)
  source      RecipeIngredientSource

  /// Snapshot display name for this ingredient.
  name_snapshot String
  /// Snapshot total calories contributed by this ingredient within the recipe.
  calories_total_snapshot Float

  /// If source=MY_FOOD, optional link back to the referenced MyFood for traceability only.
  source_my_food_id Int?
  source_my_food    MyFood? @relation("RecipeIngredientSourceFood", fields: [source_my_food_id], references: [id], onDelete: SetNull)
  /// If source=MY_FOOD, number of ingredient servings used in the recipe (can be fractional).
  quantity_servings Float?
  /// If source=MY_FOOD, snapshot of the ingredient's serving size.
  serving_size_quantity_snapshot Float?
  serving_unit_label_snapshot    String?
  calories_per_serving_snapshot  Float?

  /// If source=EXTERNAL, optional identifiers for the third-party item used to create the snapshot.
  external_source String?
  external_id     String?
  brand_snapshot  String?
  locale_snapshot String?
  barcode_snapshot String?

  /// If source=EXTERNAL, snapshot of the selected measure used to compute calories.
  measure_label_snapshot       String?
  grams_per_measure_snapshot   Float?
  measure_quantity_snapshot    Float?
  grams_total_snapshot         Float?

  created_at  DateTime  @default(now())

  @@index([recipe_id])
}

model SessionStore {
  /// Backing table for express-session; kept in the Prisma schema so db push and migrations create it.
  sid    String   @id @db.Text
  sess   Json
  expire DateTime @db.Timestamptz(6)

  @@map("session_store")
  @@index([expire], map: "session_store_expire_idx")
}

model PushSubscription {
  id              Int      @id @default(autoincrement())
  user_id         Int
  user            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  /// Browser-managed endpoint URL; unique per user so shared browsers can hold separate accounts.
  endpoint        String
  /// Base64-encoded p256dh key for payload encryption.
  p256dh          String
  /// Base64-encoded auth key for payload encryption.
  auth            String
  /// Optional expiration timestamp for the subscription.
  expiration_time DateTime?
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  @@unique([user_id, endpoint])
  @@index([user_id])
}
